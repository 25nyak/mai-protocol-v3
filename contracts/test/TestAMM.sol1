// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.7.4;
pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts-upgradeable/math/SignedSafeMathUpgradeable.sol";

import "../module/AMMModule.sol";
import "../module/AMMCommon.sol";

contract TestAMM {
    using SignedSafeMathUpgradeable for int256;
    using MarginModule for Core;
    using OracleModule for Core;

    Core core;

    function setParams(
        int256 unitAccumulativeFunding,
        int256 halfSpreadRate,
        int256 beta1,
        int256 beta2,
        int256 targetLeverage,
        int256 cashBalance,
        int256 positionAmount,
        int256 entryFunding,
        int256 indexPrice
    ) public {
        core.unitAccumulativeFunding = unitAccumulativeFunding;
        core.halfSpreadRate.value = halfSpreadRate;
        core.beta1.value = beta1;
        core.beta2.value = beta2;
        core.targetLeverage.value = targetLeverage;
        core.marginAccounts[address(this)].cashBalance = cashBalance;
        core.marginAccounts[address(this)].positionAmount = positionAmount;
        core.marginAccounts[address(this)].entryFunding = entryFunding;
        core.indexPriceData.price = indexPrice;
    }

    function isAMMMarginSafe(int256 beta) public view returns (bool) {
        int256 mc = core.availableCashBalance(address(this));
        return
            AMMCommon.isAMMMarginSafe(
                mc,
                core.marginAccounts[address(this)].positionAmount,
                core.indexPrice(),
                core.targetLeverage.value,
                beta
            );
    }

    function regress(int256 beta) public view returns (int256 mv, int256 m0) {
        int256 mc = core.availableCashBalance(address(this));
        (mv, m0) = AMMCommon.regress(
            mc,
            core.marginAccounts[address(this)].positionAmount,
            core.indexPrice(),
            core.targetLeverage.value,
            beta
        );
    }

    function virtualM0() public view returns (int256) {
        int256 mc = core.availableCashBalance(address(this));
        int256 positionAmount = core.marginAccounts[address(this)].positionAmount;
        if (positionAmount > 0) {
            return
                AMMCommon.longVirtualM0(
                    mc,
                    positionAmount,
                    core.indexPrice(),
                    core.targetLeverage.value,
                    core.beta1.value
                );
        } else {
            return
                AMMCommon.shortVirtualM0(
                    mc,
                    positionAmount,
                    core.indexPrice(),
                    core.targetLeverage.value,
                    core.beta1.value
                );
        }
    }

    function longDeltaMargin(int256 positionAmount2, int256 beta)
        public
        view
        returns (int256 deltaMargin)
    {
        int256 mc = core.availableCashBalance(address(this));
        (int256 mv, int256 m0) = regress(beta);
        deltaMargin = AMMModule.longDeltaMargin(
            m0,
            mc.add(mv),
            core.marginAccounts[address(this)].positionAmount,
            positionAmount2,
            core.indexPrice(),
            beta
        );
    }

    function shortDeltaMargin(int256 positionAmount2, int256 beta)
        public
        view
        returns (int256 deltaMargin)
    {
        int256 mc = core.availableCashBalance(address(this));
        (, int256 m0) = regress(beta);
        deltaMargin = AMMModule.shortDeltaMargin(
            m0,
            core.marginAccounts[address(this)].positionAmount,
            positionAmount2,
            core.indexPrice(),
            beta
        );
    }

    function maxLongPosition(int256 beta) public view returns (int256) {
        (, int256 m0) = regress(beta);
        return
            AMMModule._maxLongPosition(m0, core.indexPrice(), beta, core.targetLeverage.value);
    }

    function maxShortPosition(int256 beta) public view returns (int256) {
        (, int256 m0) = regress(beta);
        return
            AMMModule._maxShortPosition(
                m0,
                core.indexPrice(),
                beta,
                core.targetLeverage.value
            );
    }

    function tradeWithAMM(int256 tradingAmount, bool partialFill)
        public
        view
        returns (int256 deltaMargin, int256 deltaPosition)
    {
        (deltaMargin, deltaPosition) = AMMModule.tradeWithAMM(
            core,
            tradingAmount,
            partialFill
        );
    }

    function addLiquidity(int256 shareTotalSupply, int256 marginToAdd)
        public
        view
        returns (int256 share)
    {
        share = AMMModule.addLiquidity(core, shareTotalSupply, marginToAdd);
    }

    function removeLiquidity(int256 shareTotalSupply, int256 shareToRemove)
        public
        view
        returns (int256 marginToRemove)
    {
        marginToRemove = AMMModule.removeLiquidity(core, shareTotalSupply, shareToRemove);
    }
}
